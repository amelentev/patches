diff -crB org.eclipse.jdt.core.origin/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
*** org.eclipse.jdt.core.origin/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java	2010-10-11 22:31:49.423000884 +0600
--- org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java	2010-10-12 02:48:14.399000887 +0600
***************
*** 116,121 ****
--- 116,129 ----
  		codeStream.recordPositionsFrom(pc, this.sourceStart);
  		return;
  	}
+ 	if (this.overloadMethod != null) {
+ 		this.overloadMethod.generateCode(currentScope, codeStream, valueRequired);
+ 		if (valueRequired) {
+ 			codeStream.generateImplicitConversion(this.implicitConversion);
+ 		}
+ 		codeStream.recordPositionsFrom(pc, this.sourceStart);
+ 		return;
+ 	}
  	switch ((this.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT) {
  		case PLUS :
  			switch (this.bits & ASTNode.ReturnTypeIDMASK) {
***************
*** 1788,1793 ****
--- 1796,1810 ----
  	return this.right.printExpression(0, output);
  }
  
+ static java.util.Map operatorMethods = new java.util.HashMap() {{
+ 	put("+", "add");
+ 	put("-", "substract");
+ 	put("*", "multiply");
+ 	put("/", "divide");
+ 	put("%", "remainder");
+ }};
+ MessageSend overloadMethod;
+ 
  public TypeBinding resolveType(BlockScope scope) {
  	// keep implementation in sync with CombinedBinaryExpression#resolveType
  	// and nonRecursiveResolveTypeUpwards
***************
*** 1824,1829 ****
--- 1841,1861 ----
  		} else if (rightTypeID == TypeIds.T_JavaLangString) {
  			leftTypeID = TypeIds.T_JavaLangObject;
  		} else {
+ 			// try operator overloading
+ 			String method = (String) operatorMethods.get(this.operatorToString());
+ 			if (method != null) {
+ 				MessageSend ms = new MessageSend();
+ 				ms.arguments = new Expression[]{this.right};
+ 				ms.receiver = this.left;
+ 				ms.actualReceiverType = leftType;
+ 				ms.selector = method.toCharArray();
+ 				ms.binding = scope.getMethod(leftType, ms.selector, new TypeBinding[]{rightType}, ms);
+ 				if (ms.binding != null) {
+ 					this.overloadMethod = ms;
+ 					this.constant = Constant.NotAConstant;
+ 					return this.resolvedType = ms.resolvedType = ms.binding.returnType;
+ 				}
+ 			}
  			this.constant = Constant.NotAConstant;
  			scope.problemReporter().invalidOperator(this, leftType, rightType);
  			return null;
